import discord
from discord.ext import commands
import os
import random
import asyncio
from flask import Flask
from threading import Thread

# --- PARTIE SERVEUR POUR RENDER ---
app = Flask('')
@app.route('/')
def home(): return "Bot en ligne !"

def run(): app.run(host='0.0.0.0', port=8080)
def keep_alive():
    t = Thread(target=run)
    t.start()

# --- CONFIGURATION DU BOT ---
intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix="!", intents=intents)

def d(faces): return random.randint(1, faces)

# --- CLASSES DU JEU ---
class NameModal(discord.ui.Modal):
    def __init__(self, player_num, parent_view):
        super().__init__(title=f"Nom du Personnage - Joueur {player_num}")
        self.player_num, self.parent_view = player_num, parent_view
        self.name_input = discord.ui.TextInput(label="Nom du sorcier", min_length=2, max_length=20)
        self.add_item(self.name_input)

    async def on_submit(self, interaction: discord.Interaction):
        p_id = interaction.user.id
        self.parent_view.names[p_id] = self.name_input.value
        await interaction.response.send_message(f"âœ… Nom enregistrÃ© : **{self.name_input.value}**", ephemeral=True)
        await self.parent_view.check_start(interaction.channel)

class StartMenuView(discord.ui.View):
    def __init__(self, author):
        super().__init__(timeout=60)
        self.author = author
    @discord.ui.button(label="Mode Solo", style=discord.ButtonStyle.primary)
    async def solo(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user != self.author: return
        view = SetupMatchView(self.author, is_solo=True)
        await interaction.response.edit_message(content="ğŸ§™â€â™‚ï¸ **Mode Solo** ! Choisissez votre nom :", view=view)
    @discord.ui.button(label="Mode Duel", style=discord.ButtonStyle.success)
    async def duel(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user != self.author: return
        await interaction.response.edit_message(content="ğŸ¤ **Duel** : Tapez `!duel @nom` pour dÃ©fier quelqu'un !", view=None)

class SetupMatchView(discord.ui.View):
    def __init__(self, j1, j2=None, is_solo=False):
        super().__init__(timeout=120)
        self.j1 = j1
        self.j2_id = j2.id if j2 else "CPU"
        self.is_solo = is_solo
        self.names = {j1.id: None, self.j2_id: "Ã‰quipe adverse" if is_solo else None}
    @discord.ui.button(label="Joueur 1 : Choisir mon nom", style=discord.ButtonStyle.secondary)
    async def set_j1(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.j1.id: return await interaction.response.send_message("C'est le bouton du joueur 1 !", ephemeral=True)
        await interaction.response.send_modal(NameModal(1, self))
    @discord.ui.button(label="Joueur 2 : Choisir mon nom", style=discord.ButtonStyle.secondary)
    async def set_j2(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.is_solo or interaction.user.id != self.j2_id: return await interaction.response.send_message("Bouton rÃ©servÃ© au joueur 2 !", ephemeral=True)
        await interaction.response.send_modal(NameModal(2, self))
    async def check_start(self, channel):
        if all(v is not None for v in self.names.values()):
            self.stop()
            game = MatchView(self.j1, self.j2_id, self.names, self.is_solo)
            await game.lancer_tour(channel)

class MatchView(discord.ui.View):
    def __init__(self, j1, j2_id, names, is_solo):
        super().__init__(timeout=300)
        self.j1, self.j2_id, self.names, self.is_solo = j1, j2_id, names, is_solo
        self.scores = {j1.id: 0, j2_id: 0}
        self.tour = 1
        self.actions = {}

    async def lancer_tour(self, channel):
        self.actions = {self.j1.id: None}
        if not self.is_solo: self.actions[self.j2_id] = None
        embed = discord.Embed(title=f"ğŸŸï¸ TOUR {self.tour} / 6", color=discord.Color.blue())
        embed.description = f"**{self.names[self.j1.id]}** âš”ï¸ **{self.names[self.j2_id]}**\n\nAttente des lancers..."
        await channel.send(embed=embed, view=self)

    @discord.ui.button(label="LANCER LES DÃ‰S ğŸ²", style=discord.ButtonStyle.success)
    async def lancer_bouton(self, interaction: discord.Interaction, button: discord.ui.Button):
        uid = interaction.user.id
        if uid not in self.actions: return
        if self.actions[uid] is not None: return
        self.actions[uid] = {"atk": d(10), "def": d(6), "bat": d(4)}
        if self.is_solo: self.actions["CPU"] = {"atk": d(10), "def": d(6), "bat": d(4)}
        if all(v is not None for v in self.actions.values()):
            await interaction.response.edit_message(content="ğŸ² **Calcul des rÃ©sultats...**", embed=None, view=None)
            await self.resolution_tour(interaction.channel)
        else:
            lances = [self.names[u] for u, a in self.actions.items() if a is not None]
            status = "\n".join([f"âœ… **{n}** a lancÃ© ses dÃ©s !" for n in lances])
            embed = interaction.message.embeds[0]
            embed.description = f"**{self.names[self.j1.id]}** âš”ï¸ **{self.names[self.j2_id]}**\n\n{status}"
            await interaction.response.edit_message(embed=embed, view=self)

    async def resolution_tour(self, channel):
        n1, n2 = self.names[self.j1.id], self.names[self.j2_id]
        r1, r2 = self.actions[self.j1.id], self.actions[self.j2_id]
        def calculer(r_j, r_adv):
            nb_buts = 0
            b_v = r_j['bat']
            txt_b = f"ğŸ **Batteur ({b_v})** : "
            b_a, b_d = 0, 0
            s_a, s_d = str(r_j['atk']), str(r_j['def'])
            if b_v == 1: txt_b += "âš ï¸ **Faute ! (-2 DÃ©f)**"; b_d = -2; s_d = f"{r_j['def']}-2"
            elif b_v == 2: txt_b += "ğŸ›¡ï¸ **Renfort ! (+2 DÃ©f)**"; b_d = 2; s_d = f"{r_j['def']}+2"
            elif b_v == 3: txt_b += "ğŸ¯ **Ouverture ! (+2 Atk)**"; b_a = 2; s_a = f"{r_j['atk']}+2"
            elif b_v == 4: txt_b += "ğŸ’¥ **Exploit ! (+1 but)**"
            b_da = 0
            s_da = str(r_adv['def'])
            if r_adv['bat'] == 1: b_da = -2; s_da = f"{r_adv['def']}-2"
            elif r_adv['bat'] == 2: b_da = 2; s_da = f"{r_adv['def']}+2"
            f_a, f_da = r_j['atk'] + b_a, r_adv['def'] + b_da
            ecart = f_a - f_da
            txt_a = f"\nğŸ¹ **Attaque ({s_a})** vs **DÃ©fense ({s_da})** : "
            if ecart > 0:
                if ecart >= 8: nb_buts = 3
                elif ecart > 3: nb_buts = 2
                else: nb_buts = 1
                txt_a += f"âœ… **RÃ©ussi ! (Ã‰cart: {ecart})**"
            else: txt_a += "ğŸ§¤ **ArrÃªtÃ© !**"
            if b_v == 4: nb_buts += 1
            pts = nb_buts * 10
            return pts, f"{txt_b}{txt_a}\nâ¡ï¸ **RÃ‰SULTAT : {nb_buts} but(s) ({pts} pts)**"

        p1, d1 = calculer(r1, r2)
        p2, d2 = calculer(r2, r1)
        self.scores[self.j1.id] += p1
        self.scores[self.j2_id] += p2
        embed = discord.Embed(title=f"âš–ï¸ RÃ‰SULTATS TOUR {self.tour}", color=discord.Color.gold())
        embed.add_field(name=f"ğŸ§¤ {n1}", value=d1, inline=False)
        embed.add_field(name=f"ğŸ§¤ {n2}", value=d2, inline=False)
        embed.set_footer(text=f"Score : {n1} {self.scores[self.j1.id]} - {self.scores[self.j2_id]} {n2}")
        await channel.send(embed=embed)
        self.tour += 1
        if self.tour <= 6: await asyncio.sleep(1); await self.lancer_tour(channel)
        else: await self.vif_dor(channel)

    async def vif_dor(self, channel):
        await channel.send("\nâœ¨ **7Ã¨me TOUR : VIF D'OR !**")
        await asyncio.sleep(2)
        v1, v2 = d(100), d(100)
        n1, n2 = self.names[self.j1.id], self.names[self.j2_id]
        win_id = self.j1.id if v1 > v2 else self.j2_id
        self.scores[win_id] += 50
        embed = discord.Embed(title="ğŸŸ¡ CAPTURE", description=f"ğŸ² **{n1}** : `{v1}` | **{n2}** : `{v2}`\nğŸ† **{self.names[win_id]}** l'attrape !", color=discord.Color.yellow())
        await channel.send(embed=embed)
        winner = n1 if self.scores[self.j1.id] > self.scores[self.j2_id] else n2
        await channel.send(f"# ğŸ MATCH TERMINÃ‰\nVictoire : **{winner}** (`{self.scores[self.j1.id]}-{self.scores[self.j2_id]}`)")

@bot.command()
async def match(ctx):
    await ctx.send("ğŸ§™â€â™‚ï¸ **Bienvenue Ã  une partie de Quickdditch !**", view=StartMenuView(ctx.author))

@bot.command()
async def duel(ctx, adversaire: discord.Member):
    if adversaire.bot or adversaire == ctx.author: return
    view = SetupMatchView(ctx.author, adversaire)
    await ctx.send(f"ğŸŸï¸ **Duel lancÃ© !**\n{ctx.author.mention} et {adversaire.mention}, Ã  vos balais !", view=view)

keep_alive()
bot.run(os.environ['DISCORD_TOKEN'])